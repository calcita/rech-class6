---
title: "R aplicado a la ECH"
subtitle: "Setiembre 2020 <br> Gabriela Mathieu"
#`r icon::fa_r_project(colour = "#43a2ca")`
# author: "<br> `r icon::fa_creative_commons(colour = "#f0f0f0")` `r icon::fa_creative_commons_by(colour = "#f0f0f0")` `r icon::fa_creative_commons_sa(colour = "#f0f0f0")` <br> Gabriela Mathieu"
author: <a rel="license" href="http://creativecommons.org/licenses/by/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by/4.0/88x31.png" /></a><br /> <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>
output:
  xaringan::moon_reader:
    css: xaringan-themer.css
    #css: [default, default-fonts, rladies-fonts]
    #lib_dir: libs
    nature:
       highlightStyle: github
       highlightLines: true
       countIncrementalSlides: false
       ratio: "16:9"
       slideNumberFormat: |
        <div class="progress-bar-container">
          <div class="progress-bar" style="width: calc(%current% / %total% * 100%);">
          </div>
        </div>
---
```{r, include = F}
knitr::opts_chunk$set(fig.width = 6, message = FALSE, warning = FALSE, comment = "", cache = FALSE, fig.retina = 3)
library(flipbookr)
library(tidyverse)
library(flair)
library(kableExtra)
options(scipen = 9999)
```
```{r xaringan-themer, include=FALSE, warning=FALSE}
library(xaringanthemer)
style_duo_accent(
  #base_color = "#43a2ca",
  header_font_google = google_font("Mukta"),#Ubuntu Condensed
  text_font_google   = google_font("Montserrat", "300", "300i"),
  code_font_google   = google_font("Fira Mono"),
  primary_color      = "#0F4C81", # pantone classic blue
  secondary_color    = "#b3e2cd", # pantone baby blue
  #header_font_google = google_font("Raleway"),
  #text_font_google   = google_font("Raleway", "300", "300i"),
  #code_font_google   = google_font("Source Code Pro"),
  text_font_size     = "25px"
#   colors = c(
#   red = "#f34213",
#   purple = "#3e2f5b",
#   orange = "#ff8811",
#   green = "#136f63",
#   white = "#FFFFFF",
# )
)

```

```{r, include=FALSE}
text_spec2 <- function(x = "x"){
  text_spec(x, background = "#b3e2cd", bold = T)
}
```

```{r echo = FALSE}
library(dplyr) # cargo el paquete
load("data/ech19.RData") #importo los datos
```

# ¿Qué haremos hoy?

- Repaso
<br><br>
--

- Pobreza e indigencia: cálculo de variables y estimación de indicadores
<br><br>
--

- NBI: cálculo de variables y estimación de indicadores
<br><br>
--

- Método integrado: cálculo de variables y estimación de indicadores
<br><br>
--

- Ejercicios



---
# Medición de la pobreza

- El paquete ech proveé tres funciones para instrumentar la medición de la pobreza en personas y hogares: 
<br><br>
--

- `r text_spec2("poverty(): pobreza monetaria")`
<br><br>
--

- `r text_spec2("unsatisfied_basic_needs(): necesidades básicas insatisfechas")`
<br><br>
--

- `r text_spec2("integrated_poverty_measure(): método integrado")`

---
class: inverse, center, middle
# ech::poverty()

---
# Incidencia de la pobreza

- La función `r text_spec2("poverty()")` permite calcular la pobreza e indigencia a nivel de hogares y personas.
<br><br>
--

- El cálculo de la variable *poor* e *indigent* utiliza la Metodología 2006 que establece la medición de la pobreza por el método del ingreso usando la `r text_spec2("línea de pobreza 2006")`. 
<br><br>
--

- El Método del Ingreso, es el útilizado por el INE como `r text_spec2("medida oficial")`, define la pobreza a partir de los ingresos per cápita de los hogares. 
<br><br>
--

- De esta manera un hogar será considerado pobre `r text_spec2("si el ingreso per cápita no supera el valor de un umbral:")` la línea de pobreza (LP). A su vez, todas las personas de ese hogar, si el hogar es considerado pobre, son consideradas pobres.

---
# Cálculo de la Línea de Indigencia y la Línea de Pobreza 2006

- La construcción de las líneas 2006 se basa en los `r text_spec2("hábitos de consumo de la población del estrato de referencia definido en la ENGIH 2005-2006")`, sin introducir componentes normativos.
<br><br>
--

- `r text_spec2("Los precios de la Canasta Básica Total (CBT) se actualizan según el IPC")` (los índices de precios tanto de bienes alimentarios como no alimentarios). 
<br><br>
--

- Para determinar la LP  se  introducen  `r text_spec2("economías  de  escala  en  los  gastos  no  alimentarios  para  los  estratos  de  referencia  según la región geográfica")`,  tomando  en  cuenta  el  tamaño  del  hogar.  

Fuente: [Metodología 2006](http://www.ine.gub.uy/documents/10181/36026/Informe+Linea+de+Pobreza+2006+Final.pdf/a8ac8606-d2e1-4cfd-b038-26c46bfb9de8)

<!-- El coeficiente de Orshansky es el inverso del Coeficiente de Engel (proporción del gasto en alimentación sobre el gasto de consumo total) -->

<!-- En  la  práctica  el  Coeficiente  de  Orshansky2  (CO)  varía  a  lo  largo  del  tiempo según la evolución de los precios relativos y el tamaño del hogar. -->

---
# LI y LP

- `r text_spec2("LI del hogar")`

$CBA_{pc}*ht19$

- `r text_spec2("LP del hogar")`

$CBA_{pc}*ht19 + CBNA_{pc}*ht19^{0.8}$

El exponente que  mide  las  economías  de  escala  en  el gasto  no  alimentario es 0,8.

Veamos el código de la función poverty() y los objetos ech::cba_cbna_*

---
# Cálculamos las variables pobreza e indigencia

- En la ECH ya vienen las variables *pobre06* e *indigente06*.

- La función poverty() calcula las variables *poor* e *indigent*.

```{r}
# cargamos el paquete 
library(ech); library(dplyr)

# cargamos los datos
load("data/ech19.RData")

# calculamos las variables de pobreza monteria
ech19 <- poverty(data = ech19) #<<
```

---
# Estimamos la incidencia de la pobreza e indigencia

Estimamos la incidencia de la pobreza en hogares y en personas usando la función `r text_spec2("get_estimation_mean()")`

```{r eval = FALSE}
# Hogares según situación de pobreza 
pobres_hogares <- get_estimation_mean(ech19, variable = "poor", level = "h", ids = "upm", estrato = "estrato") #<<

# Personas según situación de pobreza 
pobres_personas <- get_estimation_mean(ech19, variable = "poor", level = "i", ids = "upm", estrato = "estrato") #<<

# Hogares según situación de indigencia
indigencia_hogares <- get_estimation_mean(ech19, variable = "indigent", level = "h", ids = "upm", estrato = "estrato") #<<

# Personas según situación de indigencia
indigencia_personas <- get_estimation_mean(ech19, variable = "indigent", level = "i", ids = "upm", estrato = "estrato") #<<
```
---
# Ejercicio 

- Estimar el total de personas y  hogares pobres.    

- Estimar la incidencia de la pobreza en hogares por área geográfica 

- Estimar la incidencia de la pobreza en personas por área geográfica 

- Estimar la incidencia de la pobreza en hogares por departamento

- Estimar la incidencia de la pobreza en personas por área geográfica, según grupos de edades: 0-5, 6-12, 13-17, 18-64 y 65+

- Estimar la incidencia de la pobreza en personas por área geográfica, según ascendencia declarada de las personas (afro, blanca, otra)

Comparar con las estimaciones del [INE](http://www.ine.gub.uy/documents/10181/364159/Estimaci%C3%B3n+de+la+pobreza+por+el+M%C3%A9todo+del+Ingreso+2017/f990baaf-1c32-44c5-beda-59a20dd8325c)

---
class: inverse, center, middle
# ech::unsatisfied_basic_needs()

---
# Necesidades Básicas Insatisfechas

- La función unsatisfied_basic_needs() permite calcular variables que identifica necesidades básicas insatisfechas (NBI) en ciertas dimensiones que el hogar debería satisfacer para `r text_spec2("lograr un mínimo de bienestar")` y luego agregarlas en un indicador. 
<br><br>
--

- Se usa una aproximación de la Metodología del Censo 2011. Las dimensiones consideradas son: `r text_spec2("hacinamiento, acceso a agua potable, acceso a energía eléctrica, materiales de la vivienda, evacuación del servicio sanitario y educación")`. 
<br><br>
--

- La dimensión de educación se evalua para las personas entre 4 a 17 años y si al menos una de estas personas tiene una carencia en educación se considera que todo el hogar tiene carencia en esta dimensión. 
<br><br>
--

- Se evalúa para cada una de estas dimensiones `r text_spec2("si hay o no carencia")`, luego se suman y se obtiene la variable *UBN_q* (toma valores entre 0 a 6) y *UBN* (“Sin NBI”, “Con 1 NBI”, “Con 2 NBI” y “Con 3 o más NBI”). Los resultados se calculan al nivel del hogar y se imputan a todas las personas del hogar.

---
# Cálculo y estimación de las NBI

Para calcular las NBI previamente debemos calcular la asistencia escolar y los años de educación.

```{r eval = FALSE}
# Calculamos las variables de NBI
ech19 <- enrolled_school(ech19)
ech19 <- years_of_schooling(ech19)
ech19 <- unsatisfied_basic_needs(data = ech19) #<<
```

Estimamos la variable cantidad de NBI 

```{r eval = FALSE}
# Distribución de hogares según cantidad de NBI que presenta
nbi_hogares <- get_estimation_mean(ech19, variable = "UBN", level = "h", ids = "upm", estrato = "estrato") #<<

# Distribución de personas según cantidad de NBI que presenta el hogar
nbi_personas <- get_estimation_mean(ech19, variable = "UBN", level = "i", ids = "upm", estrato = "estrato") #<<
```

---
class: inverse, center, middle
# ech::integrated_poverty_measure()

---
# Método integrado de medición de la pobreza

- El método integrado `r text_spec2("combina el método del ingreso con el de NBI")`.
<br><br>
--

- La función integrated_poverty_measure() permite calcular un indicador que vincula los dos métodos anteriores, de ahí el nombre de método integrado. 
<br><br>
--

- Se calcula la variable *integrated_poverty_measure* que toma 4 valores: `r text_spec2("'No pobreza', 'Pobreza reciente', 'Pobreza inercial' y 'Pobreza crónica'")`.

| NBI / Pobreza | Pobre | No pobre |
|--------|---------|--------------|
| Con al menos una carencia | Pobreza crónica | Pobreza inercial |  
| Ausencia de carencia  | Pobreza reciente    |   No pobres |

---
# Método integrado

Previamente debemos haber calculado las variables pobreza y NBI

```{r eval = FALSE}
# calculamos la variable metodo integrado
ech19 <- integrated_poverty_measure(data = ech19) #<<
```

Estimamos la proporción de hogares según el método integrado

```{r eval = FALSE}

# Hogares según situación de pobreza
ipm_hogares <- get_estimation_mean(ech19, variable = "integrated_poverty_measure", level = "h", ids = "upm", estrato = "estrato")
```

---
# geouy & ech

- Generamos un mapa de coropletas con la estimación de la incidencia de la pobreza por departamento.

- Primero estimamos pobreza en hogares por deparamento usando el paquete ech.

```{r}
pobre_x_dpto <- get_estimation_mean(data = ech19, # Indico el data.frame
                                    variable = "pobre06", # La variable a estimar
                                    by.x = "nomdpto", # La variable de agrupación
                                    level = "h", # Defino que lo haga a nivel de hogar
                                    name = "Pobreza")  %>%
        filter(pobre06 == "Pobre")
```

---
# Mapa de coropletas

El uso de este paquete se potencia al usarlo en conjunto con [geouy](https://github.com/RichDeto/geouy) ya que permite acceder a diferentes capas geográficas de Uruguay y construir mapas temáticos. 

Por ejemplo, a la estimación anterior de hogares pobres por departamento se le pueden agregar las geometrías de los polígonos de cada departamento para construir un mapa de coropletas.

```{r}
# Agrego geometrías
pobre_x_dpto_geo <- add_geom(data = pobre_x_dpto, # Los datos en una unidad geográfica de entre las opciones
                             unit = "Departamentos", # Unidad de agregación de los datos
                             variable = "nomdpto") # Variable correspondiente a los códigos a la unidad
```

---
# Mapa de coropletas

.pull-left[
```{r eval = FALSE}
# Hago un mapa
plot_geouy(x = pobre_x_dpto_geo, 
           col = "Pobreza",
           l = "%")
```
]



.pull-right[
```{r echo = FALSE}
# Hago un mapa
plot_geouy(x = pobre_x_dpto_geo, col = "Pobreza", l = "%")
```
]

---
<!-- # Resultados oficiales  -->

<!-- Podemos comparar estos resultados que brinda el paquete ech, con el Boletín Técnico que publica el INE. -->

<!-- Concretamente para comparar los resultados con el cuadro 20 y 21, primero calculamos la variable poor con la función poverty() y luego estimamos la proporción de hogares y personas pobres según región (consideramos la variable region_4). -->

<!-- ```{r eval = FALSE} -->
<!-- df <- poverty(data = df) -->

<!-- # Hogares según situación de pobreza  -->
<!-- pobres_hogares_region <- get_estimation_mean(df, variable = "poor", by.x = "region_3",level = "h", ids = "upm", estrato = "estrato") -->
<!-- pobres_hogares_region %>% filter(poor == "Pobre") -->

<!-- # Personas según situación de pobreza  -->
<!-- pobres_personas_region <- get_estimation_mean(df, variable = "poor", by.x = "region_3", level = "i", ids = "upm", estrato = "estrato") -->
<!-- pobres_personas_region %>% filter(poor == "Pobre") -->
<!-- ``` -->

